// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `management.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct JanusGraphContext {
    // message fields
    pub graphName: ::std::string::String,
    pub storageBackend: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JanusGraphContext {
    fn default() -> &'a JanusGraphContext {
        <JanusGraphContext as ::protobuf::Message>::default_instance()
    }
}

impl JanusGraphContext {
    pub fn new() -> JanusGraphContext {
        ::std::default::Default::default()
    }

    // string graphName = 1;


    pub fn get_graphName(&self) -> &str {
        &self.graphName
    }
    pub fn clear_graphName(&mut self) {
        self.graphName.clear();
    }

    // Param is passed by value, moved
    pub fn set_graphName(&mut self, v: ::std::string::String) {
        self.graphName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graphName(&mut self) -> &mut ::std::string::String {
        &mut self.graphName
    }

    // Take field
    pub fn take_graphName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.graphName, ::std::string::String::new())
    }

    // string storageBackend = 2;


    pub fn get_storageBackend(&self) -> &str {
        &self.storageBackend
    }
    pub fn clear_storageBackend(&mut self) {
        self.storageBackend.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageBackend(&mut self, v: ::std::string::String) {
        self.storageBackend = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageBackend(&mut self) -> &mut ::std::string::String {
        &mut self.storageBackend
    }

    // Take field
    pub fn take_storageBackend(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storageBackend, ::std::string::String::new())
    }
}

impl ::protobuf::Message for JanusGraphContext {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.graphName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storageBackend)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.storageBackend.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.storageBackend);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.storageBackend.is_empty() {
            os.write_string(2, &self.storageBackend)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JanusGraphContext {
        JanusGraphContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "graphName",
                    |m: &JanusGraphContext| { &m.graphName },
                    |m: &mut JanusGraphContext| { &mut m.graphName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageBackend",
                    |m: &JanusGraphContext| { &m.storageBackend },
                    |m: &mut JanusGraphContext| { &mut m.storageBackend },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<JanusGraphContext>(
                    "JanusGraphContext",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static JanusGraphContext {
        static mut instance: ::protobuf::lazy::Lazy<JanusGraphContext> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(JanusGraphContext::new)
        }
    }
}

impl ::protobuf::Clear for JanusGraphContext {
    fn clear(&mut self) {
        self.graphName.clear();
        self.storageBackend.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JanusGraphContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JanusGraphContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContextByGraphNameRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContextByGraphNameRequest {
    fn default() -> &'a GetContextByGraphNameRequest {
        <GetContextByGraphNameRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetContextByGraphNameRequest {
    pub fn new() -> GetContextByGraphNameRequest {
        ::std::default::Default::default()
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetContextByGraphNameRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContextByGraphNameRequest {
        GetContextByGraphNameRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetContextByGraphNameRequest| { &m.name },
                    |m: &mut GetContextByGraphNameRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetContextByGraphNameRequest>(
                    "GetContextByGraphNameRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetContextByGraphNameRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetContextByGraphNameRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetContextByGraphNameRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetContextByGraphNameRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContextByGraphNameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContextByGraphNameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContextsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContextsRequest {
    fn default() -> &'a GetContextsRequest {
        <GetContextsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetContextsRequest {
    pub fn new() -> GetContextsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetContextsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContextsRequest {
        GetContextsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetContextsRequest>(
                    "GetContextsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetContextsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetContextsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetContextsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetContextsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContextsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContextsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexProperty {
    // message fields
    pub id: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub name: ::std::string::String,
    pub dataType: PropertyDataType,
    pub cardinality: VertexProperty_Cardinality,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VertexProperty {
    fn default() -> &'a VertexProperty {
        <VertexProperty as ::protobuf::Message>::default_instance()
    }
}

impl VertexProperty {
    pub fn new() -> VertexProperty {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value id = 1;


    pub fn get_id(&self) -> &::protobuf::well_known_types::Int64Value {
        self.id.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.id.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .grpc.PropertyDataType dataType = 3;


    pub fn get_dataType(&self) -> PropertyDataType {
        self.dataType
    }
    pub fn clear_dataType(&mut self) {
        self.dataType = PropertyDataType::String;
    }

    // Param is passed by value, moved
    pub fn set_dataType(&mut self, v: PropertyDataType) {
        self.dataType = v;
    }

    // .grpc.VertexProperty.Cardinality cardinality = 4;


    pub fn get_cardinality(&self) -> VertexProperty_Cardinality {
        self.cardinality
    }
    pub fn clear_cardinality(&mut self) {
        self.cardinality = VertexProperty_Cardinality::Single;
    }

    // Param is passed by value, moved
    pub fn set_cardinality(&mut self, v: VertexProperty_Cardinality) {
        self.cardinality = v;
    }
}

impl ::protobuf::Message for VertexProperty {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.cardinality, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.dataType != PropertyDataType::String {
            my_size += ::protobuf::rt::enum_size(3, self.dataType);
        }
        if self.cardinality != VertexProperty_Cardinality::Single {
            my_size += ::protobuf::rt::enum_size(4, self.cardinality);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.dataType != PropertyDataType::String {
            os.write_enum(3, self.dataType.value())?;
        }
        if self.cardinality != VertexProperty_Cardinality::Single {
            os.write_enum(4, self.cardinality.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexProperty {
        VertexProperty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                    "id",
                    |m: &VertexProperty| { &m.id },
                    |m: &mut VertexProperty| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &VertexProperty| { &m.name },
                    |m: &mut VertexProperty| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PropertyDataType>>(
                    "dataType",
                    |m: &VertexProperty| { &m.dataType },
                    |m: &mut VertexProperty| { &mut m.dataType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VertexProperty_Cardinality>>(
                    "cardinality",
                    |m: &VertexProperty| { &m.cardinality },
                    |m: &mut VertexProperty| { &mut m.cardinality },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VertexProperty>(
                    "VertexProperty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VertexProperty {
        static mut instance: ::protobuf::lazy::Lazy<VertexProperty> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VertexProperty::new)
        }
    }
}

impl ::protobuf::Clear for VertexProperty {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.dataType = PropertyDataType::String;
        self.cardinality = VertexProperty_Cardinality::Single;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexProperty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VertexProperty_Cardinality {
    Single = 0,
    List = 1,
    Set = 2,
}

impl ::protobuf::ProtobufEnum for VertexProperty_Cardinality {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VertexProperty_Cardinality> {
        match value {
            0 => ::std::option::Option::Some(VertexProperty_Cardinality::Single),
            1 => ::std::option::Option::Some(VertexProperty_Cardinality::List),
            2 => ::std::option::Option::Some(VertexProperty_Cardinality::Set),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VertexProperty_Cardinality] = &[
            VertexProperty_Cardinality::Single,
            VertexProperty_Cardinality::List,
            VertexProperty_Cardinality::Set,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<VertexProperty_Cardinality>("VertexProperty.Cardinality", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VertexProperty_Cardinality {
}

impl ::std::default::Default for VertexProperty_Cardinality {
    fn default() -> Self {
        VertexProperty_Cardinality::Single
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexProperty_Cardinality {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexLabel {
    // message fields
    pub id: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub name: ::std::string::String,
    pub properties: ::protobuf::RepeatedField<VertexProperty>,
    pub readOnly: bool,
    pub partitioned: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VertexLabel {
    fn default() -> &'a VertexLabel {
        <VertexLabel as ::protobuf::Message>::default_instance()
    }
}

impl VertexLabel {
    pub fn new() -> VertexLabel {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value id = 1;


    pub fn get_id(&self) -> &::protobuf::well_known_types::Int64Value {
        self.id.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.id.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .grpc.VertexProperty properties = 3;


    pub fn get_properties(&self) -> &[VertexProperty] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<VertexProperty>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<VertexProperty> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<VertexProperty> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // bool readOnly = 4;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = false;
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = v;
    }

    // bool partitioned = 5;


    pub fn get_partitioned(&self) -> bool {
        self.partitioned
    }
    pub fn clear_partitioned(&mut self) {
        self.partitioned = false;
    }

    // Param is passed by value, moved
    pub fn set_partitioned(&mut self, v: bool) {
        self.partitioned = v;
    }
}

impl ::protobuf::Message for VertexLabel {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.partitioned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.readOnly != false {
            my_size += 2;
        }
        if self.partitioned != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.readOnly != false {
            os.write_bool(4, self.readOnly)?;
        }
        if self.partitioned != false {
            os.write_bool(5, self.partitioned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexLabel {
        VertexLabel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                    "id",
                    |m: &VertexLabel| { &m.id },
                    |m: &mut VertexLabel| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &VertexLabel| { &m.name },
                    |m: &mut VertexLabel| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexProperty>>(
                    "properties",
                    |m: &VertexLabel| { &m.properties },
                    |m: &mut VertexLabel| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    |m: &VertexLabel| { &m.readOnly },
                    |m: &mut VertexLabel| { &mut m.readOnly },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "partitioned",
                    |m: &VertexLabel| { &m.partitioned },
                    |m: &mut VertexLabel| { &mut m.partitioned },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VertexLabel>(
                    "VertexLabel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VertexLabel {
        static mut instance: ::protobuf::lazy::Lazy<VertexLabel> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VertexLabel::new)
        }
    }
}

impl ::protobuf::Clear for VertexLabel {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.properties.clear();
        self.readOnly = false;
        self.partitioned = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexLabel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexLabel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetVertexLabelsByNameRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetVertexLabelsByNameRequest {
    fn default() -> &'a GetVertexLabelsByNameRequest {
        <GetVertexLabelsByNameRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetVertexLabelsByNameRequest {
    pub fn new() -> GetVertexLabelsByNameRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetVertexLabelsByNameRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetVertexLabelsByNameRequest {
        GetVertexLabelsByNameRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &GetVertexLabelsByNameRequest| { &m.context },
                    |m: &mut GetVertexLabelsByNameRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetVertexLabelsByNameRequest| { &m.name },
                    |m: &mut GetVertexLabelsByNameRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetVertexLabelsByNameRequest>(
                    "GetVertexLabelsByNameRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetVertexLabelsByNameRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetVertexLabelsByNameRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetVertexLabelsByNameRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetVertexLabelsByNameRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetVertexLabelsByNameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVertexLabelsByNameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnsureVertexLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub label: ::protobuf::SingularPtrField<VertexLabel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnsureVertexLabelRequest {
    fn default() -> &'a EnsureVertexLabelRequest {
        <EnsureVertexLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnsureVertexLabelRequest {
    pub fn new() -> EnsureVertexLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.VertexLabel label = 2;


    pub fn get_label(&self) -> &VertexLabel {
        self.label.as_ref().unwrap_or_else(|| VertexLabel::default_instance())
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: VertexLabel) {
        self.label = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut VertexLabel {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> VertexLabel {
        self.label.take().unwrap_or_else(|| VertexLabel::new())
    }
}

impl ::protobuf::Message for EnsureVertexLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.label.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnsureVertexLabelRequest {
        EnsureVertexLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &EnsureVertexLabelRequest| { &m.context },
                    |m: &mut EnsureVertexLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexLabel>>(
                    "label",
                    |m: &EnsureVertexLabelRequest| { &m.label },
                    |m: &mut EnsureVertexLabelRequest| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnsureVertexLabelRequest>(
                    "EnsureVertexLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnsureVertexLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnsureVertexLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EnsureVertexLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnsureVertexLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnsureVertexLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnsureVertexLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetVertexLabelsRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetVertexLabelsRequest {
    fn default() -> &'a GetVertexLabelsRequest {
        <GetVertexLabelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetVertexLabelsRequest {
    pub fn new() -> GetVertexLabelsRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }
}

impl ::protobuf::Message for GetVertexLabelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetVertexLabelsRequest {
        GetVertexLabelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &GetVertexLabelsRequest| { &m.context },
                    |m: &mut GetVertexLabelsRequest| { &mut m.context },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetVertexLabelsRequest>(
                    "GetVertexLabelsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetVertexLabelsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetVertexLabelsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetVertexLabelsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetVertexLabelsRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetVertexLabelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVertexLabelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeProperty {
    // message fields
    pub id: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub name: ::std::string::String,
    pub dataType: PropertyDataType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EdgeProperty {
    fn default() -> &'a EdgeProperty {
        <EdgeProperty as ::protobuf::Message>::default_instance()
    }
}

impl EdgeProperty {
    pub fn new() -> EdgeProperty {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value id = 1;


    pub fn get_id(&self) -> &::protobuf::well_known_types::Int64Value {
        self.id.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.id.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .grpc.PropertyDataType dataType = 3;


    pub fn get_dataType(&self) -> PropertyDataType {
        self.dataType
    }
    pub fn clear_dataType(&mut self) {
        self.dataType = PropertyDataType::String;
    }

    // Param is passed by value, moved
    pub fn set_dataType(&mut self, v: PropertyDataType) {
        self.dataType = v;
    }
}

impl ::protobuf::Message for EdgeProperty {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataType, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.dataType != PropertyDataType::String {
            my_size += ::protobuf::rt::enum_size(3, self.dataType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.dataType != PropertyDataType::String {
            os.write_enum(3, self.dataType.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeProperty {
        EdgeProperty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                    "id",
                    |m: &EdgeProperty| { &m.id },
                    |m: &mut EdgeProperty| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &EdgeProperty| { &m.name },
                    |m: &mut EdgeProperty| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PropertyDataType>>(
                    "dataType",
                    |m: &EdgeProperty| { &m.dataType },
                    |m: &mut EdgeProperty| { &mut m.dataType },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EdgeProperty>(
                    "EdgeProperty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeProperty {
        static mut instance: ::protobuf::lazy::Lazy<EdgeProperty> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EdgeProperty::new)
        }
    }
}

impl ::protobuf::Clear for EdgeProperty {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.dataType = PropertyDataType::String;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeProperty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeLabel {
    // message fields
    pub id: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub name: ::std::string::String,
    pub properties: ::protobuf::RepeatedField<EdgeProperty>,
    pub direction: EdgeLabel_Direction,
    pub multiplicity: EdgeLabel_Multiplicity,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EdgeLabel {
    fn default() -> &'a EdgeLabel {
        <EdgeLabel as ::protobuf::Message>::default_instance()
    }
}

impl EdgeLabel {
    pub fn new() -> EdgeLabel {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value id = 1;


    pub fn get_id(&self) -> &::protobuf::well_known_types::Int64Value {
        self.id.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.id.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .grpc.EdgeProperty properties = 3;


    pub fn get_properties(&self) -> &[EdgeProperty] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<EdgeProperty>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<EdgeProperty> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<EdgeProperty> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // .grpc.EdgeLabel.Direction direction = 4;


    pub fn get_direction(&self) -> EdgeLabel_Direction {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = EdgeLabel_Direction::BOTH;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EdgeLabel_Direction) {
        self.direction = v;
    }

    // .grpc.EdgeLabel.Multiplicity multiplicity = 5;


    pub fn get_multiplicity(&self) -> EdgeLabel_Multiplicity {
        self.multiplicity
    }
    pub fn clear_multiplicity(&mut self) {
        self.multiplicity = EdgeLabel_Multiplicity::Multi;
    }

    // Param is passed by value, moved
    pub fn set_multiplicity(&mut self, v: EdgeLabel_Multiplicity) {
        self.multiplicity = v;
    }
}

impl ::protobuf::Message for EdgeLabel {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.multiplicity, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.direction != EdgeLabel_Direction::BOTH {
            my_size += ::protobuf::rt::enum_size(4, self.direction);
        }
        if self.multiplicity != EdgeLabel_Multiplicity::Multi {
            my_size += ::protobuf::rt::enum_size(5, self.multiplicity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.direction != EdgeLabel_Direction::BOTH {
            os.write_enum(4, self.direction.value())?;
        }
        if self.multiplicity != EdgeLabel_Multiplicity::Multi {
            os.write_enum(5, self.multiplicity.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeLabel {
        EdgeLabel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                    "id",
                    |m: &EdgeLabel| { &m.id },
                    |m: &mut EdgeLabel| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &EdgeLabel| { &m.name },
                    |m: &mut EdgeLabel| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeProperty>>(
                    "properties",
                    |m: &EdgeLabel| { &m.properties },
                    |m: &mut EdgeLabel| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EdgeLabel_Direction>>(
                    "direction",
                    |m: &EdgeLabel| { &m.direction },
                    |m: &mut EdgeLabel| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EdgeLabel_Multiplicity>>(
                    "multiplicity",
                    |m: &EdgeLabel| { &m.multiplicity },
                    |m: &mut EdgeLabel| { &mut m.multiplicity },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EdgeLabel>(
                    "EdgeLabel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeLabel {
        static mut instance: ::protobuf::lazy::Lazy<EdgeLabel> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EdgeLabel::new)
        }
    }
}

impl ::protobuf::Clear for EdgeLabel {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.properties.clear();
        self.direction = EdgeLabel_Direction::BOTH;
        self.multiplicity = EdgeLabel_Multiplicity::Multi;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeLabel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeLabel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EdgeLabel_Direction {
    BOTH = 0,
    OUT = 1,
}

impl ::protobuf::ProtobufEnum for EdgeLabel_Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EdgeLabel_Direction> {
        match value {
            0 => ::std::option::Option::Some(EdgeLabel_Direction::BOTH),
            1 => ::std::option::Option::Some(EdgeLabel_Direction::OUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EdgeLabel_Direction] = &[
            EdgeLabel_Direction::BOTH,
            EdgeLabel_Direction::OUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<EdgeLabel_Direction>("EdgeLabel.Direction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EdgeLabel_Direction {
}

impl ::std::default::Default for EdgeLabel_Direction {
    fn default() -> Self {
        EdgeLabel_Direction::BOTH
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeLabel_Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EdgeLabel_Multiplicity {
    Multi = 0,
    Simple = 1,
    One2Many = 2,
    Many2One = 3,
    One2One = 4,
}

impl ::protobuf::ProtobufEnum for EdgeLabel_Multiplicity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EdgeLabel_Multiplicity> {
        match value {
            0 => ::std::option::Option::Some(EdgeLabel_Multiplicity::Multi),
            1 => ::std::option::Option::Some(EdgeLabel_Multiplicity::Simple),
            2 => ::std::option::Option::Some(EdgeLabel_Multiplicity::One2Many),
            3 => ::std::option::Option::Some(EdgeLabel_Multiplicity::Many2One),
            4 => ::std::option::Option::Some(EdgeLabel_Multiplicity::One2One),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EdgeLabel_Multiplicity] = &[
            EdgeLabel_Multiplicity::Multi,
            EdgeLabel_Multiplicity::Simple,
            EdgeLabel_Multiplicity::One2Many,
            EdgeLabel_Multiplicity::Many2One,
            EdgeLabel_Multiplicity::One2One,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<EdgeLabel_Multiplicity>("EdgeLabel.Multiplicity", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EdgeLabel_Multiplicity {
}

impl ::std::default::Default for EdgeLabel_Multiplicity {
    fn default() -> Self {
        EdgeLabel_Multiplicity::Multi
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeLabel_Multiplicity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEdgeLabelsByNameRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEdgeLabelsByNameRequest {
    fn default() -> &'a GetEdgeLabelsByNameRequest {
        <GetEdgeLabelsByNameRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEdgeLabelsByNameRequest {
    pub fn new() -> GetEdgeLabelsByNameRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetEdgeLabelsByNameRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEdgeLabelsByNameRequest {
        GetEdgeLabelsByNameRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &GetEdgeLabelsByNameRequest| { &m.context },
                    |m: &mut GetEdgeLabelsByNameRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetEdgeLabelsByNameRequest| { &m.name },
                    |m: &mut GetEdgeLabelsByNameRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEdgeLabelsByNameRequest>(
                    "GetEdgeLabelsByNameRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetEdgeLabelsByNameRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetEdgeLabelsByNameRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetEdgeLabelsByNameRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetEdgeLabelsByNameRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEdgeLabelsByNameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEdgeLabelsByNameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnsureEdgeLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub label: ::protobuf::SingularPtrField<EdgeLabel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnsureEdgeLabelRequest {
    fn default() -> &'a EnsureEdgeLabelRequest {
        <EnsureEdgeLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnsureEdgeLabelRequest {
    pub fn new() -> EnsureEdgeLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.EdgeLabel label = 2;


    pub fn get_label(&self) -> &EdgeLabel {
        self.label.as_ref().unwrap_or_else(|| EdgeLabel::default_instance())
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: EdgeLabel) {
        self.label = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut EdgeLabel {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> EdgeLabel {
        self.label.take().unwrap_or_else(|| EdgeLabel::new())
    }
}

impl ::protobuf::Message for EnsureEdgeLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.label.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnsureEdgeLabelRequest {
        EnsureEdgeLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &EnsureEdgeLabelRequest| { &m.context },
                    |m: &mut EnsureEdgeLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeLabel>>(
                    "label",
                    |m: &EnsureEdgeLabelRequest| { &m.label },
                    |m: &mut EnsureEdgeLabelRequest| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnsureEdgeLabelRequest>(
                    "EnsureEdgeLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnsureEdgeLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnsureEdgeLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EnsureEdgeLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnsureEdgeLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnsureEdgeLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnsureEdgeLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEdgeLabelsRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEdgeLabelsRequest {
    fn default() -> &'a GetEdgeLabelsRequest {
        <GetEdgeLabelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEdgeLabelsRequest {
    pub fn new() -> GetEdgeLabelsRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }
}

impl ::protobuf::Message for GetEdgeLabelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEdgeLabelsRequest {
        GetEdgeLabelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &GetEdgeLabelsRequest| { &m.context },
                    |m: &mut GetEdgeLabelsRequest| { &mut m.context },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEdgeLabelsRequest>(
                    "GetEdgeLabelsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetEdgeLabelsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetEdgeLabelsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetEdgeLabelsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetEdgeLabelsRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEdgeLabelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEdgeLabelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompositeVertexIndex {
    // message fields
    pub id: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub name: ::std::string::String,
    pub properties: ::protobuf::RepeatedField<VertexProperty>,
    pub unique: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompositeVertexIndex {
    fn default() -> &'a CompositeVertexIndex {
        <CompositeVertexIndex as ::protobuf::Message>::default_instance()
    }
}

impl CompositeVertexIndex {
    pub fn new() -> CompositeVertexIndex {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value id = 1;


    pub fn get_id(&self) -> &::protobuf::well_known_types::Int64Value {
        self.id.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.id.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .grpc.VertexProperty properties = 3;


    pub fn get_properties(&self) -> &[VertexProperty] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<VertexProperty>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<VertexProperty> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<VertexProperty> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // bool unique = 4;


    pub fn get_unique(&self) -> bool {
        self.unique
    }
    pub fn clear_unique(&mut self) {
        self.unique = false;
    }

    // Param is passed by value, moved
    pub fn set_unique(&mut self, v: bool) {
        self.unique = v;
    }
}

impl ::protobuf::Message for CompositeVertexIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.unique != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.unique != false {
            os.write_bool(4, self.unique)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompositeVertexIndex {
        CompositeVertexIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                    "id",
                    |m: &CompositeVertexIndex| { &m.id },
                    |m: &mut CompositeVertexIndex| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CompositeVertexIndex| { &m.name },
                    |m: &mut CompositeVertexIndex| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexProperty>>(
                    "properties",
                    |m: &CompositeVertexIndex| { &m.properties },
                    |m: &mut CompositeVertexIndex| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unique",
                    |m: &CompositeVertexIndex| { &m.unique },
                    |m: &mut CompositeVertexIndex| { &mut m.unique },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompositeVertexIndex>(
                    "CompositeVertexIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompositeVertexIndex {
        static mut instance: ::protobuf::lazy::Lazy<CompositeVertexIndex> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CompositeVertexIndex::new)
        }
    }
}

impl ::protobuf::Clear for CompositeVertexIndex {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.properties.clear();
        self.unique = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompositeVertexIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompositeVertexIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCompositeIndicesByVertexLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub vertexLabel: ::protobuf::SingularPtrField<VertexLabel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCompositeIndicesByVertexLabelRequest {
    fn default() -> &'a GetCompositeIndicesByVertexLabelRequest {
        <GetCompositeIndicesByVertexLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCompositeIndicesByVertexLabelRequest {
    pub fn new() -> GetCompositeIndicesByVertexLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.VertexLabel vertexLabel = 2;


    pub fn get_vertexLabel(&self) -> &VertexLabel {
        self.vertexLabel.as_ref().unwrap_or_else(|| VertexLabel::default_instance())
    }
    pub fn clear_vertexLabel(&mut self) {
        self.vertexLabel.clear();
    }

    pub fn has_vertexLabel(&self) -> bool {
        self.vertexLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertexLabel(&mut self, v: VertexLabel) {
        self.vertexLabel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vertexLabel(&mut self) -> &mut VertexLabel {
        if self.vertexLabel.is_none() {
            self.vertexLabel.set_default();
        }
        self.vertexLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_vertexLabel(&mut self) -> VertexLabel {
        self.vertexLabel.take().unwrap_or_else(|| VertexLabel::new())
    }
}

impl ::protobuf::Message for GetCompositeIndicesByVertexLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vertexLabel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vertexLabel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vertexLabel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vertexLabel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCompositeIndicesByVertexLabelRequest {
        GetCompositeIndicesByVertexLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &GetCompositeIndicesByVertexLabelRequest| { &m.context },
                    |m: &mut GetCompositeIndicesByVertexLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexLabel>>(
                    "vertexLabel",
                    |m: &GetCompositeIndicesByVertexLabelRequest| { &m.vertexLabel },
                    |m: &mut GetCompositeIndicesByVertexLabelRequest| { &mut m.vertexLabel },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCompositeIndicesByVertexLabelRequest>(
                    "GetCompositeIndicesByVertexLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetCompositeIndicesByVertexLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetCompositeIndicesByVertexLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetCompositeIndicesByVertexLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetCompositeIndicesByVertexLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.vertexLabel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCompositeIndicesByVertexLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCompositeIndicesByVertexLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnsureCompositeIndexByVertexLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub vertexLabel: ::protobuf::SingularPtrField<VertexLabel>,
    pub index: ::protobuf::SingularPtrField<CompositeVertexIndex>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnsureCompositeIndexByVertexLabelRequest {
    fn default() -> &'a EnsureCompositeIndexByVertexLabelRequest {
        <EnsureCompositeIndexByVertexLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnsureCompositeIndexByVertexLabelRequest {
    pub fn new() -> EnsureCompositeIndexByVertexLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.VertexLabel vertexLabel = 2;


    pub fn get_vertexLabel(&self) -> &VertexLabel {
        self.vertexLabel.as_ref().unwrap_or_else(|| VertexLabel::default_instance())
    }
    pub fn clear_vertexLabel(&mut self) {
        self.vertexLabel.clear();
    }

    pub fn has_vertexLabel(&self) -> bool {
        self.vertexLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertexLabel(&mut self, v: VertexLabel) {
        self.vertexLabel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vertexLabel(&mut self) -> &mut VertexLabel {
        if self.vertexLabel.is_none() {
            self.vertexLabel.set_default();
        }
        self.vertexLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_vertexLabel(&mut self) -> VertexLabel {
        self.vertexLabel.take().unwrap_or_else(|| VertexLabel::new())
    }

    // .grpc.CompositeVertexIndex index = 3;


    pub fn get_index(&self) -> &CompositeVertexIndex {
        self.index.as_ref().unwrap_or_else(|| CompositeVertexIndex::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: CompositeVertexIndex) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut CompositeVertexIndex {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> CompositeVertexIndex {
        self.index.take().unwrap_or_else(|| CompositeVertexIndex::new())
    }
}

impl ::protobuf::Message for EnsureCompositeIndexByVertexLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vertexLabel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vertexLabel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vertexLabel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vertexLabel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnsureCompositeIndexByVertexLabelRequest {
        EnsureCompositeIndexByVertexLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &EnsureCompositeIndexByVertexLabelRequest| { &m.context },
                    |m: &mut EnsureCompositeIndexByVertexLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexLabel>>(
                    "vertexLabel",
                    |m: &EnsureCompositeIndexByVertexLabelRequest| { &m.vertexLabel },
                    |m: &mut EnsureCompositeIndexByVertexLabelRequest| { &mut m.vertexLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompositeVertexIndex>>(
                    "index",
                    |m: &EnsureCompositeIndexByVertexLabelRequest| { &m.index },
                    |m: &mut EnsureCompositeIndexByVertexLabelRequest| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnsureCompositeIndexByVertexLabelRequest>(
                    "EnsureCompositeIndexByVertexLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnsureCompositeIndexByVertexLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnsureCompositeIndexByVertexLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EnsureCompositeIndexByVertexLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnsureCompositeIndexByVertexLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.vertexLabel.clear();
        self.index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnsureCompositeIndexByVertexLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnsureCompositeIndexByVertexLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MixedVertexIndex {
    // message fields
    pub id: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub name: ::std::string::String,
    pub properties: ::protobuf::RepeatedField<VertexProperty>,
    pub unique: bool,
    pub backend: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MixedVertexIndex {
    fn default() -> &'a MixedVertexIndex {
        <MixedVertexIndex as ::protobuf::Message>::default_instance()
    }
}

impl MixedVertexIndex {
    pub fn new() -> MixedVertexIndex {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value id = 1;


    pub fn get_id(&self) -> &::protobuf::well_known_types::Int64Value {
        self.id.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.id.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .grpc.VertexProperty properties = 3;


    pub fn get_properties(&self) -> &[VertexProperty] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<VertexProperty>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<VertexProperty> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<VertexProperty> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // bool unique = 4;


    pub fn get_unique(&self) -> bool {
        self.unique
    }
    pub fn clear_unique(&mut self) {
        self.unique = false;
    }

    // Param is passed by value, moved
    pub fn set_unique(&mut self, v: bool) {
        self.unique = v;
    }

    // string backend = 5;


    pub fn get_backend(&self) -> &str {
        &self.backend
    }
    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: ::std::string::String) {
        self.backend = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut ::std::string::String {
        &mut self.backend
    }

    // Take field
    pub fn take_backend(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backend, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MixedVertexIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backend)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.unique != false {
            my_size += 2;
        }
        if !self.backend.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.backend);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.unique != false {
            os.write_bool(4, self.unique)?;
        }
        if !self.backend.is_empty() {
            os.write_string(5, &self.backend)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MixedVertexIndex {
        MixedVertexIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                    "id",
                    |m: &MixedVertexIndex| { &m.id },
                    |m: &mut MixedVertexIndex| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &MixedVertexIndex| { &m.name },
                    |m: &mut MixedVertexIndex| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexProperty>>(
                    "properties",
                    |m: &MixedVertexIndex| { &m.properties },
                    |m: &mut MixedVertexIndex| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unique",
                    |m: &MixedVertexIndex| { &m.unique },
                    |m: &mut MixedVertexIndex| { &mut m.unique },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "backend",
                    |m: &MixedVertexIndex| { &m.backend },
                    |m: &mut MixedVertexIndex| { &mut m.backend },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MixedVertexIndex>(
                    "MixedVertexIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MixedVertexIndex {
        static mut instance: ::protobuf::lazy::Lazy<MixedVertexIndex> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MixedVertexIndex::new)
        }
    }
}

impl ::protobuf::Clear for MixedVertexIndex {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.properties.clear();
        self.unique = false;
        self.backend.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MixedVertexIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MixedVertexIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMixedIndicesByVertexLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub vertexLabel: ::protobuf::SingularPtrField<VertexLabel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMixedIndicesByVertexLabelRequest {
    fn default() -> &'a GetMixedIndicesByVertexLabelRequest {
        <GetMixedIndicesByVertexLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMixedIndicesByVertexLabelRequest {
    pub fn new() -> GetMixedIndicesByVertexLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.VertexLabel vertexLabel = 2;


    pub fn get_vertexLabel(&self) -> &VertexLabel {
        self.vertexLabel.as_ref().unwrap_or_else(|| VertexLabel::default_instance())
    }
    pub fn clear_vertexLabel(&mut self) {
        self.vertexLabel.clear();
    }

    pub fn has_vertexLabel(&self) -> bool {
        self.vertexLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertexLabel(&mut self, v: VertexLabel) {
        self.vertexLabel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vertexLabel(&mut self) -> &mut VertexLabel {
        if self.vertexLabel.is_none() {
            self.vertexLabel.set_default();
        }
        self.vertexLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_vertexLabel(&mut self) -> VertexLabel {
        self.vertexLabel.take().unwrap_or_else(|| VertexLabel::new())
    }
}

impl ::protobuf::Message for GetMixedIndicesByVertexLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vertexLabel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vertexLabel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vertexLabel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vertexLabel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMixedIndicesByVertexLabelRequest {
        GetMixedIndicesByVertexLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &GetMixedIndicesByVertexLabelRequest| { &m.context },
                    |m: &mut GetMixedIndicesByVertexLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexLabel>>(
                    "vertexLabel",
                    |m: &GetMixedIndicesByVertexLabelRequest| { &m.vertexLabel },
                    |m: &mut GetMixedIndicesByVertexLabelRequest| { &mut m.vertexLabel },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMixedIndicesByVertexLabelRequest>(
                    "GetMixedIndicesByVertexLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetMixedIndicesByVertexLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetMixedIndicesByVertexLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetMixedIndicesByVertexLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetMixedIndicesByVertexLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.vertexLabel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMixedIndicesByVertexLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMixedIndicesByVertexLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnsureMixedIndexByVertexLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub vertexLabel: ::protobuf::SingularPtrField<VertexLabel>,
    pub index: ::protobuf::SingularPtrField<MixedVertexIndex>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnsureMixedIndexByVertexLabelRequest {
    fn default() -> &'a EnsureMixedIndexByVertexLabelRequest {
        <EnsureMixedIndexByVertexLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnsureMixedIndexByVertexLabelRequest {
    pub fn new() -> EnsureMixedIndexByVertexLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.VertexLabel vertexLabel = 2;


    pub fn get_vertexLabel(&self) -> &VertexLabel {
        self.vertexLabel.as_ref().unwrap_or_else(|| VertexLabel::default_instance())
    }
    pub fn clear_vertexLabel(&mut self) {
        self.vertexLabel.clear();
    }

    pub fn has_vertexLabel(&self) -> bool {
        self.vertexLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertexLabel(&mut self, v: VertexLabel) {
        self.vertexLabel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vertexLabel(&mut self) -> &mut VertexLabel {
        if self.vertexLabel.is_none() {
            self.vertexLabel.set_default();
        }
        self.vertexLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_vertexLabel(&mut self) -> VertexLabel {
        self.vertexLabel.take().unwrap_or_else(|| VertexLabel::new())
    }

    // .grpc.MixedVertexIndex index = 3;


    pub fn get_index(&self) -> &MixedVertexIndex {
        self.index.as_ref().unwrap_or_else(|| MixedVertexIndex::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: MixedVertexIndex) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut MixedVertexIndex {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> MixedVertexIndex {
        self.index.take().unwrap_or_else(|| MixedVertexIndex::new())
    }
}

impl ::protobuf::Message for EnsureMixedIndexByVertexLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vertexLabel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vertexLabel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vertexLabel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vertexLabel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnsureMixedIndexByVertexLabelRequest {
        EnsureMixedIndexByVertexLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &EnsureMixedIndexByVertexLabelRequest| { &m.context },
                    |m: &mut EnsureMixedIndexByVertexLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexLabel>>(
                    "vertexLabel",
                    |m: &EnsureMixedIndexByVertexLabelRequest| { &m.vertexLabel },
                    |m: &mut EnsureMixedIndexByVertexLabelRequest| { &mut m.vertexLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MixedVertexIndex>>(
                    "index",
                    |m: &EnsureMixedIndexByVertexLabelRequest| { &m.index },
                    |m: &mut EnsureMixedIndexByVertexLabelRequest| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnsureMixedIndexByVertexLabelRequest>(
                    "EnsureMixedIndexByVertexLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnsureMixedIndexByVertexLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnsureMixedIndexByVertexLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EnsureMixedIndexByVertexLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnsureMixedIndexByVertexLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.vertexLabel.clear();
        self.index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnsureMixedIndexByVertexLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnsureMixedIndexByVertexLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompositeEdgeIndex {
    // message fields
    pub id: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub name: ::std::string::String,
    pub properties: ::protobuf::RepeatedField<EdgeProperty>,
    pub unique: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompositeEdgeIndex {
    fn default() -> &'a CompositeEdgeIndex {
        <CompositeEdgeIndex as ::protobuf::Message>::default_instance()
    }
}

impl CompositeEdgeIndex {
    pub fn new() -> CompositeEdgeIndex {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value id = 1;


    pub fn get_id(&self) -> &::protobuf::well_known_types::Int64Value {
        self.id.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.id.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .grpc.EdgeProperty properties = 3;


    pub fn get_properties(&self) -> &[EdgeProperty] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<EdgeProperty>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<EdgeProperty> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<EdgeProperty> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // bool unique = 4;


    pub fn get_unique(&self) -> bool {
        self.unique
    }
    pub fn clear_unique(&mut self) {
        self.unique = false;
    }

    // Param is passed by value, moved
    pub fn set_unique(&mut self, v: bool) {
        self.unique = v;
    }
}

impl ::protobuf::Message for CompositeEdgeIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.unique != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.unique != false {
            os.write_bool(4, self.unique)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompositeEdgeIndex {
        CompositeEdgeIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                    "id",
                    |m: &CompositeEdgeIndex| { &m.id },
                    |m: &mut CompositeEdgeIndex| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CompositeEdgeIndex| { &m.name },
                    |m: &mut CompositeEdgeIndex| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeProperty>>(
                    "properties",
                    |m: &CompositeEdgeIndex| { &m.properties },
                    |m: &mut CompositeEdgeIndex| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unique",
                    |m: &CompositeEdgeIndex| { &m.unique },
                    |m: &mut CompositeEdgeIndex| { &mut m.unique },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompositeEdgeIndex>(
                    "CompositeEdgeIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompositeEdgeIndex {
        static mut instance: ::protobuf::lazy::Lazy<CompositeEdgeIndex> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CompositeEdgeIndex::new)
        }
    }
}

impl ::protobuf::Clear for CompositeEdgeIndex {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.properties.clear();
        self.unique = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompositeEdgeIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompositeEdgeIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCompositeIndicesByEdgeLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub edgeLabel: ::protobuf::SingularPtrField<EdgeLabel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCompositeIndicesByEdgeLabelRequest {
    fn default() -> &'a GetCompositeIndicesByEdgeLabelRequest {
        <GetCompositeIndicesByEdgeLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCompositeIndicesByEdgeLabelRequest {
    pub fn new() -> GetCompositeIndicesByEdgeLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.EdgeLabel edgeLabel = 2;


    pub fn get_edgeLabel(&self) -> &EdgeLabel {
        self.edgeLabel.as_ref().unwrap_or_else(|| EdgeLabel::default_instance())
    }
    pub fn clear_edgeLabel(&mut self) {
        self.edgeLabel.clear();
    }

    pub fn has_edgeLabel(&self) -> bool {
        self.edgeLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeLabel(&mut self, v: EdgeLabel) {
        self.edgeLabel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeLabel(&mut self) -> &mut EdgeLabel {
        if self.edgeLabel.is_none() {
            self.edgeLabel.set_default();
        }
        self.edgeLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeLabel(&mut self) -> EdgeLabel {
        self.edgeLabel.take().unwrap_or_else(|| EdgeLabel::new())
    }
}

impl ::protobuf::Message for GetCompositeIndicesByEdgeLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edgeLabel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeLabel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.edgeLabel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.edgeLabel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCompositeIndicesByEdgeLabelRequest {
        GetCompositeIndicesByEdgeLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &GetCompositeIndicesByEdgeLabelRequest| { &m.context },
                    |m: &mut GetCompositeIndicesByEdgeLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeLabel>>(
                    "edgeLabel",
                    |m: &GetCompositeIndicesByEdgeLabelRequest| { &m.edgeLabel },
                    |m: &mut GetCompositeIndicesByEdgeLabelRequest| { &mut m.edgeLabel },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCompositeIndicesByEdgeLabelRequest>(
                    "GetCompositeIndicesByEdgeLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetCompositeIndicesByEdgeLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetCompositeIndicesByEdgeLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetCompositeIndicesByEdgeLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetCompositeIndicesByEdgeLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.edgeLabel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCompositeIndicesByEdgeLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCompositeIndicesByEdgeLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnsureCompositeIndexByEdgeLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub edgeLabel: ::protobuf::SingularPtrField<EdgeLabel>,
    pub index: ::protobuf::SingularPtrField<CompositeEdgeIndex>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnsureCompositeIndexByEdgeLabelRequest {
    fn default() -> &'a EnsureCompositeIndexByEdgeLabelRequest {
        <EnsureCompositeIndexByEdgeLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnsureCompositeIndexByEdgeLabelRequest {
    pub fn new() -> EnsureCompositeIndexByEdgeLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.EdgeLabel edgeLabel = 2;


    pub fn get_edgeLabel(&self) -> &EdgeLabel {
        self.edgeLabel.as_ref().unwrap_or_else(|| EdgeLabel::default_instance())
    }
    pub fn clear_edgeLabel(&mut self) {
        self.edgeLabel.clear();
    }

    pub fn has_edgeLabel(&self) -> bool {
        self.edgeLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeLabel(&mut self, v: EdgeLabel) {
        self.edgeLabel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeLabel(&mut self) -> &mut EdgeLabel {
        if self.edgeLabel.is_none() {
            self.edgeLabel.set_default();
        }
        self.edgeLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeLabel(&mut self) -> EdgeLabel {
        self.edgeLabel.take().unwrap_or_else(|| EdgeLabel::new())
    }

    // .grpc.CompositeEdgeIndex index = 3;


    pub fn get_index(&self) -> &CompositeEdgeIndex {
        self.index.as_ref().unwrap_or_else(|| CompositeEdgeIndex::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: CompositeEdgeIndex) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut CompositeEdgeIndex {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> CompositeEdgeIndex {
        self.index.take().unwrap_or_else(|| CompositeEdgeIndex::new())
    }
}

impl ::protobuf::Message for EnsureCompositeIndexByEdgeLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edgeLabel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeLabel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.edgeLabel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.edgeLabel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnsureCompositeIndexByEdgeLabelRequest {
        EnsureCompositeIndexByEdgeLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &EnsureCompositeIndexByEdgeLabelRequest| { &m.context },
                    |m: &mut EnsureCompositeIndexByEdgeLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeLabel>>(
                    "edgeLabel",
                    |m: &EnsureCompositeIndexByEdgeLabelRequest| { &m.edgeLabel },
                    |m: &mut EnsureCompositeIndexByEdgeLabelRequest| { &mut m.edgeLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompositeEdgeIndex>>(
                    "index",
                    |m: &EnsureCompositeIndexByEdgeLabelRequest| { &m.index },
                    |m: &mut EnsureCompositeIndexByEdgeLabelRequest| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnsureCompositeIndexByEdgeLabelRequest>(
                    "EnsureCompositeIndexByEdgeLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnsureCompositeIndexByEdgeLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnsureCompositeIndexByEdgeLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EnsureCompositeIndexByEdgeLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnsureCompositeIndexByEdgeLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.edgeLabel.clear();
        self.index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnsureCompositeIndexByEdgeLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnsureCompositeIndexByEdgeLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MixedEdgeIndex {
    // message fields
    pub id: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub name: ::std::string::String,
    pub properties: ::protobuf::RepeatedField<EdgeProperty>,
    pub unique: bool,
    pub backend: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MixedEdgeIndex {
    fn default() -> &'a MixedEdgeIndex {
        <MixedEdgeIndex as ::protobuf::Message>::default_instance()
    }
}

impl MixedEdgeIndex {
    pub fn new() -> MixedEdgeIndex {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value id = 1;


    pub fn get_id(&self) -> &::protobuf::well_known_types::Int64Value {
        self.id.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.id.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .grpc.EdgeProperty properties = 3;


    pub fn get_properties(&self) -> &[EdgeProperty] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<EdgeProperty>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<EdgeProperty> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<EdgeProperty> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // bool unique = 4;


    pub fn get_unique(&self) -> bool {
        self.unique
    }
    pub fn clear_unique(&mut self) {
        self.unique = false;
    }

    // Param is passed by value, moved
    pub fn set_unique(&mut self, v: bool) {
        self.unique = v;
    }

    // string backend = 5;


    pub fn get_backend(&self) -> &str {
        &self.backend
    }
    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: ::std::string::String) {
        self.backend = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut ::std::string::String {
        &mut self.backend
    }

    // Take field
    pub fn take_backend(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backend, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MixedEdgeIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backend)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.unique != false {
            my_size += 2;
        }
        if !self.backend.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.backend);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.unique != false {
            os.write_bool(4, self.unique)?;
        }
        if !self.backend.is_empty() {
            os.write_string(5, &self.backend)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MixedEdgeIndex {
        MixedEdgeIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                    "id",
                    |m: &MixedEdgeIndex| { &m.id },
                    |m: &mut MixedEdgeIndex| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &MixedEdgeIndex| { &m.name },
                    |m: &mut MixedEdgeIndex| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeProperty>>(
                    "properties",
                    |m: &MixedEdgeIndex| { &m.properties },
                    |m: &mut MixedEdgeIndex| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unique",
                    |m: &MixedEdgeIndex| { &m.unique },
                    |m: &mut MixedEdgeIndex| { &mut m.unique },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "backend",
                    |m: &MixedEdgeIndex| { &m.backend },
                    |m: &mut MixedEdgeIndex| { &mut m.backend },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MixedEdgeIndex>(
                    "MixedEdgeIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MixedEdgeIndex {
        static mut instance: ::protobuf::lazy::Lazy<MixedEdgeIndex> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MixedEdgeIndex::new)
        }
    }
}

impl ::protobuf::Clear for MixedEdgeIndex {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.properties.clear();
        self.unique = false;
        self.backend.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MixedEdgeIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MixedEdgeIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMixedIndicesByEdgeLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub edgeLabel: ::protobuf::SingularPtrField<EdgeLabel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMixedIndicesByEdgeLabelRequest {
    fn default() -> &'a GetMixedIndicesByEdgeLabelRequest {
        <GetMixedIndicesByEdgeLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMixedIndicesByEdgeLabelRequest {
    pub fn new() -> GetMixedIndicesByEdgeLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.EdgeLabel edgeLabel = 2;


    pub fn get_edgeLabel(&self) -> &EdgeLabel {
        self.edgeLabel.as_ref().unwrap_or_else(|| EdgeLabel::default_instance())
    }
    pub fn clear_edgeLabel(&mut self) {
        self.edgeLabel.clear();
    }

    pub fn has_edgeLabel(&self) -> bool {
        self.edgeLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeLabel(&mut self, v: EdgeLabel) {
        self.edgeLabel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeLabel(&mut self) -> &mut EdgeLabel {
        if self.edgeLabel.is_none() {
            self.edgeLabel.set_default();
        }
        self.edgeLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeLabel(&mut self) -> EdgeLabel {
        self.edgeLabel.take().unwrap_or_else(|| EdgeLabel::new())
    }
}

impl ::protobuf::Message for GetMixedIndicesByEdgeLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edgeLabel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeLabel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.edgeLabel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.edgeLabel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMixedIndicesByEdgeLabelRequest {
        GetMixedIndicesByEdgeLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &GetMixedIndicesByEdgeLabelRequest| { &m.context },
                    |m: &mut GetMixedIndicesByEdgeLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeLabel>>(
                    "edgeLabel",
                    |m: &GetMixedIndicesByEdgeLabelRequest| { &m.edgeLabel },
                    |m: &mut GetMixedIndicesByEdgeLabelRequest| { &mut m.edgeLabel },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMixedIndicesByEdgeLabelRequest>(
                    "GetMixedIndicesByEdgeLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetMixedIndicesByEdgeLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetMixedIndicesByEdgeLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetMixedIndicesByEdgeLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetMixedIndicesByEdgeLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.edgeLabel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMixedIndicesByEdgeLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMixedIndicesByEdgeLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnsureMixedIndexByEdgeLabelRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<JanusGraphContext>,
    pub edgeLabel: ::protobuf::SingularPtrField<EdgeLabel>,
    pub index: ::protobuf::SingularPtrField<MixedEdgeIndex>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnsureMixedIndexByEdgeLabelRequest {
    fn default() -> &'a EnsureMixedIndexByEdgeLabelRequest {
        <EnsureMixedIndexByEdgeLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnsureMixedIndexByEdgeLabelRequest {
    pub fn new() -> EnsureMixedIndexByEdgeLabelRequest {
        ::std::default::Default::default()
    }

    // .grpc.JanusGraphContext context = 1;


    pub fn get_context(&self) -> &JanusGraphContext {
        self.context.as_ref().unwrap_or_else(|| JanusGraphContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: JanusGraphContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut JanusGraphContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> JanusGraphContext {
        self.context.take().unwrap_or_else(|| JanusGraphContext::new())
    }

    // .grpc.EdgeLabel edgeLabel = 2;


    pub fn get_edgeLabel(&self) -> &EdgeLabel {
        self.edgeLabel.as_ref().unwrap_or_else(|| EdgeLabel::default_instance())
    }
    pub fn clear_edgeLabel(&mut self) {
        self.edgeLabel.clear();
    }

    pub fn has_edgeLabel(&self) -> bool {
        self.edgeLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeLabel(&mut self, v: EdgeLabel) {
        self.edgeLabel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeLabel(&mut self) -> &mut EdgeLabel {
        if self.edgeLabel.is_none() {
            self.edgeLabel.set_default();
        }
        self.edgeLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeLabel(&mut self) -> EdgeLabel {
        self.edgeLabel.take().unwrap_or_else(|| EdgeLabel::new())
    }

    // .grpc.MixedEdgeIndex index = 3;


    pub fn get_index(&self) -> &MixedEdgeIndex {
        self.index.as_ref().unwrap_or_else(|| MixedEdgeIndex::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: MixedEdgeIndex) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut MixedEdgeIndex {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> MixedEdgeIndex {
        self.index.take().unwrap_or_else(|| MixedEdgeIndex::new())
    }
}

impl ::protobuf::Message for EnsureMixedIndexByEdgeLabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edgeLabel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeLabel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.edgeLabel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.edgeLabel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnsureMixedIndexByEdgeLabelRequest {
        EnsureMixedIndexByEdgeLabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JanusGraphContext>>(
                    "context",
                    |m: &EnsureMixedIndexByEdgeLabelRequest| { &m.context },
                    |m: &mut EnsureMixedIndexByEdgeLabelRequest| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeLabel>>(
                    "edgeLabel",
                    |m: &EnsureMixedIndexByEdgeLabelRequest| { &m.edgeLabel },
                    |m: &mut EnsureMixedIndexByEdgeLabelRequest| { &mut m.edgeLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MixedEdgeIndex>>(
                    "index",
                    |m: &EnsureMixedIndexByEdgeLabelRequest| { &m.index },
                    |m: &mut EnsureMixedIndexByEdgeLabelRequest| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnsureMixedIndexByEdgeLabelRequest>(
                    "EnsureMixedIndexByEdgeLabelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnsureMixedIndexByEdgeLabelRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnsureMixedIndexByEdgeLabelRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EnsureMixedIndexByEdgeLabelRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnsureMixedIndexByEdgeLabelRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.edgeLabel.clear();
        self.index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnsureMixedIndexByEdgeLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnsureMixedIndexByEdgeLabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PropertyDataType {
    String = 0,
    Character = 1,
    Boolean = 2,
    Int8 = 3,
    Int16 = 4,
    Int32 = 5,
    Int64 = 6,
    Float32 = 7,
    Float64 = 8,
    Date = 9,
    JavaObject = 10,
    GeoShape = 11,
    Uuid = 12,
}

impl ::protobuf::ProtobufEnum for PropertyDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PropertyDataType> {
        match value {
            0 => ::std::option::Option::Some(PropertyDataType::String),
            1 => ::std::option::Option::Some(PropertyDataType::Character),
            2 => ::std::option::Option::Some(PropertyDataType::Boolean),
            3 => ::std::option::Option::Some(PropertyDataType::Int8),
            4 => ::std::option::Option::Some(PropertyDataType::Int16),
            5 => ::std::option::Option::Some(PropertyDataType::Int32),
            6 => ::std::option::Option::Some(PropertyDataType::Int64),
            7 => ::std::option::Option::Some(PropertyDataType::Float32),
            8 => ::std::option::Option::Some(PropertyDataType::Float64),
            9 => ::std::option::Option::Some(PropertyDataType::Date),
            10 => ::std::option::Option::Some(PropertyDataType::JavaObject),
            11 => ::std::option::Option::Some(PropertyDataType::GeoShape),
            12 => ::std::option::Option::Some(PropertyDataType::Uuid),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PropertyDataType] = &[
            PropertyDataType::String,
            PropertyDataType::Character,
            PropertyDataType::Boolean,
            PropertyDataType::Int8,
            PropertyDataType::Int16,
            PropertyDataType::Int32,
            PropertyDataType::Int64,
            PropertyDataType::Float32,
            PropertyDataType::Float64,
            PropertyDataType::Date,
            PropertyDataType::JavaObject,
            PropertyDataType::GeoShape,
            PropertyDataType::Uuid,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<PropertyDataType>("PropertyDataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PropertyDataType {
}

impl ::std::default::Default for PropertyDataType {
    fn default() -> Self {
        PropertyDataType::String
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10management.proto\x12\x04grpc\x1a\x1egoogle/protobuf/wrappers.proto\
    \"Y\n\x11JanusGraphContext\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgra\
    phName\x12&\n\x0estorageBackend\x18\x02\x20\x01(\tR\x0estorageBackend\"2\
    \n\x1cGetContextByGraphNameRequest\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\"\x14\n\x12GetContextsRequest\"\xf7\x01\n\x0eVertexProperty\x12\
    +\n\x02id\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x02id\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x122\n\x08dataType\x18\
    \x03\x20\x01(\x0e2\x16.grpc.PropertyDataTypeR\x08dataType\x12B\n\x0bcard\
    inality\x18\x04\x20\x01(\x0e2\x20.grpc.VertexProperty.CardinalityR\x0bca\
    rdinality\",\n\x0bCardinality\x12\n\n\x06Single\x10\0\x12\x08\n\x04List\
    \x10\x01\x12\x07\n\x03Set\x10\x02\"\xc2\x01\n\x0bVertexLabel\x12+\n\x02i\
    d\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x02id\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x124\n\nproperties\x18\x03\x20\x03(\
    \x0b2\x14.grpc.VertexPropertyR\nproperties\x12\x1a\n\x08readOnly\x18\x04\
    \x20\x01(\x08R\x08readOnly\x12\x20\n\x0bpartitioned\x18\x05\x20\x01(\x08\
    R\x0bpartitioned\"e\n\x1cGetVertexLabelsByNameRequest\x121\n\x07context\
    \x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphContextR\x07context\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\"v\n\x18EnsureVertexLabelRequest\
    \x121\n\x07context\x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphContextR\x07\
    context\x12'\n\x05label\x18\x02\x20\x01(\x0b2\x11.grpc.VertexLabelR\x05l\
    abel\"K\n\x16GetVertexLabelsRequest\x121\n\x07context\x18\x01\x20\x01(\
    \x0b2\x17.grpc.JanusGraphContextR\x07context\"\x83\x01\n\x0cEdgeProperty\
    \x12+\n\x02id\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x02i\
    d\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x122\n\x08dataType\x18\
    \x03\x20\x01(\x0e2\x16.grpc.PropertyDataTypeR\x08dataType\"\xeb\x02\n\tE\
    dgeLabel\x12+\n\x02id\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.Int64Val\
    ueR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x122\n\nproperti\
    es\x18\x03\x20\x03(\x0b2\x12.grpc.EdgePropertyR\nproperties\x127\n\tdire\
    ction\x18\x04\x20\x01(\x0e2\x19.grpc.EdgeLabel.DirectionR\tdirection\x12\
    @\n\x0cmultiplicity\x18\x05\x20\x01(\x0e2\x1c.grpc.EdgeLabel.Multiplicit\
    yR\x0cmultiplicity\"\x1e\n\tDirection\x12\x08\n\x04BOTH\x10\0\x12\x07\n\
    \x03OUT\x10\x01\"N\n\x0cMultiplicity\x12\t\n\x05Multi\x10\0\x12\n\n\x06S\
    imple\x10\x01\x12\x0c\n\x08One2Many\x10\x02\x12\x0c\n\x08Many2One\x10\
    \x03\x12\x0b\n\x07One2One\x10\x04\"c\n\x1aGetEdgeLabelsByNameRequest\x12\
    1\n\x07context\x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphContextR\x07cont\
    ext\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"r\n\x16EnsureEdgeLabe\
    lRequest\x121\n\x07context\x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphCont\
    extR\x07context\x12%\n\x05label\x18\x02\x20\x01(\x0b2\x0f.grpc.EdgeLabel\
    R\x05label\"I\n\x14GetEdgeLabelsRequest\x121\n\x07context\x18\x01\x20\
    \x01(\x0b2\x17.grpc.JanusGraphContextR\x07context\"\xa5\x01\n\x14Composi\
    teVertexIndex\x12+\n\x02id\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.Int\
    64ValueR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x124\n\npro\
    perties\x18\x03\x20\x03(\x0b2\x14.grpc.VertexPropertyR\nproperties\x12\
    \x16\n\x06unique\x18\x04\x20\x01(\x08R\x06unique\"\x91\x01\n'GetComposit\
    eIndicesByVertexLabelRequest\x121\n\x07context\x18\x01\x20\x01(\x0b2\x17\
    .grpc.JanusGraphContextR\x07context\x123\n\x0bvertexLabel\x18\x02\x20\
    \x01(\x0b2\x11.grpc.VertexLabelR\x0bvertexLabel\"\xc4\x01\n(EnsureCompos\
    iteIndexByVertexLabelRequest\x121\n\x07context\x18\x01\x20\x01(\x0b2\x17\
    .grpc.JanusGraphContextR\x07context\x123\n\x0bvertexLabel\x18\x02\x20\
    \x01(\x0b2\x11.grpc.VertexLabelR\x0bvertexLabel\x120\n\x05index\x18\x03\
    \x20\x01(\x0b2\x1a.grpc.CompositeVertexIndexR\x05index\"\xbb\x01\n\x10Mi\
    xedVertexIndex\x12+\n\x02id\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.In\
    t64ValueR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x124\n\npr\
    operties\x18\x03\x20\x03(\x0b2\x14.grpc.VertexPropertyR\nproperties\x12\
    \x16\n\x06unique\x18\x04\x20\x01(\x08R\x06unique\x12\x18\n\x07backend\
    \x18\x05\x20\x01(\tR\x07backend\"\x8d\x01\n#GetMixedIndicesByVertexLabel\
    Request\x121\n\x07context\x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphConte\
    xtR\x07context\x123\n\x0bvertexLabel\x18\x02\x20\x01(\x0b2\x11.grpc.Vert\
    exLabelR\x0bvertexLabel\"\xbc\x01\n$EnsureMixedIndexByVertexLabelRequest\
    \x121\n\x07context\x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphContextR\x07\
    context\x123\n\x0bvertexLabel\x18\x02\x20\x01(\x0b2\x11.grpc.VertexLabel\
    R\x0bvertexLabel\x12,\n\x05index\x18\x03\x20\x01(\x0b2\x16.grpc.MixedVer\
    texIndexR\x05index\"\xa1\x01\n\x12CompositeEdgeIndex\x12+\n\x02id\x18\
    \x01\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x02id\x12\x12\n\x04na\
    me\x18\x02\x20\x01(\tR\x04name\x122\n\nproperties\x18\x03\x20\x03(\x0b2\
    \x12.grpc.EdgePropertyR\nproperties\x12\x16\n\x06unique\x18\x04\x20\x01(\
    \x08R\x06unique\"\x89\x01\n%GetCompositeIndicesByEdgeLabelRequest\x121\n\
    \x07context\x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphContextR\x07context\
    \x12-\n\tedgeLabel\x18\x02\x20\x01(\x0b2\x0f.grpc.EdgeLabelR\tedgeLabel\
    \"\xba\x01\n&EnsureCompositeIndexByEdgeLabelRequest\x121\n\x07context\
    \x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphContextR\x07context\x12-\n\ted\
    geLabel\x18\x02\x20\x01(\x0b2\x0f.grpc.EdgeLabelR\tedgeLabel\x12.\n\x05i\
    ndex\x18\x03\x20\x01(\x0b2\x18.grpc.CompositeEdgeIndexR\x05index\"\xb7\
    \x01\n\x0eMixedEdgeIndex\x12+\n\x02id\x18\x01\x20\x01(\x0b2\x1b.google.p\
    rotobuf.Int64ValueR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \x122\n\nproperties\x18\x03\x20\x03(\x0b2\x12.grpc.EdgePropertyR\nproper\
    ties\x12\x16\n\x06unique\x18\x04\x20\x01(\x08R\x06unique\x12\x18\n\x07ba\
    ckend\x18\x05\x20\x01(\tR\x07backend\"\x85\x01\n!GetMixedIndicesByEdgeLa\
    belRequest\x121\n\x07context\x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphCo\
    ntextR\x07context\x12-\n\tedgeLabel\x18\x02\x20\x01(\x0b2\x0f.grpc.EdgeL\
    abelR\tedgeLabel\"\xb2\x01\n\"EnsureMixedIndexByEdgeLabelRequest\x121\n\
    \x07context\x18\x01\x20\x01(\x0b2\x17.grpc.JanusGraphContextR\x07context\
    \x12-\n\tedgeLabel\x18\x02\x20\x01(\x0b2\x0f.grpc.EdgeLabelR\tedgeLabel\
    \x12*\n\x05index\x18\x03\x20\x01(\x0b2\x14.grpc.MixedEdgeIndexR\x05index\
    *\xb1\x01\n\x10PropertyDataType\x12\n\n\x06String\x10\0\x12\r\n\tCharact\
    er\x10\x01\x12\x0b\n\x07Boolean\x10\x02\x12\x08\n\x04Int8\x10\x03\x12\t\
    \n\x05Int16\x10\x04\x12\t\n\x05Int32\x10\x05\x12\t\n\x05Int64\x10\x06\
    \x12\x0b\n\x07Float32\x10\x07\x12\x0b\n\x07Float64\x10\x08\x12\x08\n\x04\
    Date\x10\t\x12\x0e\n\nJavaObject\x10\n\x12\x0c\n\x08GeoShape\x10\x0b\x12\
    \x08\n\x04Uuid\x10\x0c2\xa9\x01\n\rAccessContext\x12B\n\x0bGetContexts\
    \x12\x18.grpc.GetContextsRequest\x1a\x17.grpc.JanusGraphContext0\x01\x12\
    T\n\x15GetContextByGraphName\x12\".grpc.GetContextByGraphNameRequest\x1a\
    \x17.grpc.JanusGraphContext2\xfb\x04\n\x17ManagementForEdgeLabels\x12>\n\
    \rGetEdgeLabels\x12\x1a.grpc.GetEdgeLabelsRequest\x1a\x0f.grpc.EdgeLabel\
    0\x01\x12J\n\x13GetEdgeLabelsByName\x12\x20.grpc.GetEdgeLabelsByNameRequ\
    est\x1a\x0f.grpc.EdgeLabel0\x01\x12@\n\x0fEnsureEdgeLabel\x12\x1c.grpc.E\
    nsureEdgeLabelRequest\x1a\x0f.grpc.EdgeLabel\x12i\n\x1eGetCompositeIndic\
    esByEdgeLabel\x12+.grpc.GetCompositeIndicesByEdgeLabelRequest\x1a\x18.gr\
    pc.CompositeEdgeIndex0\x01\x12i\n\x1fEnsureCompositeIndexByEdgeLabel\x12\
    ,.grpc.EnsureCompositeIndexByEdgeLabelRequest\x1a\x18.grpc.CompositeEdge\
    Index\x12]\n\x1aGetMixedIndicesByEdgeLabel\x12'.grpc.GetMixedIndicesByEd\
    geLabelRequest\x1a\x14.grpc.MixedEdgeIndex0\x01\x12]\n\x1bEnsureMixedInd\
    exByEdgeLabel\x12(.grpc.EnsureMixedIndexByEdgeLabelRequest\x1a\x14.grpc.\
    MixedEdgeIndex2\xa7\x05\n\x19ManagementForVertexLabels\x12D\n\x0fGetVert\
    exLabels\x12\x1c.grpc.GetVertexLabelsRequest\x1a\x11.grpc.VertexLabel0\
    \x01\x12P\n\x15GetVertexLabelsByName\x12\".grpc.GetVertexLabelsByNameReq\
    uest\x1a\x11.grpc.VertexLabel0\x01\x12F\n\x11EnsureVertexLabel\x12\x1e.g\
    rpc.EnsureVertexLabelRequest\x1a\x11.grpc.VertexLabel\x12o\n\x20GetCompo\
    siteIndicesByVertexLabel\x12-.grpc.GetCompositeIndicesByVertexLabelReque\
    st\x1a\x1a.grpc.CompositeVertexIndex0\x01\x12o\n!EnsureCompositeIndexByV\
    ertexLabel\x12..grpc.EnsureCompositeIndexByVertexLabelRequest\x1a\x1a.gr\
    pc.CompositeVertexIndex\x12c\n\x1cGetMixedIndicesByVertexLabel\x12).grpc\
    .GetMixedIndicesByVertexLabelRequest\x1a\x16.grpc.MixedVertexIndex0\x01\
    \x12c\n\x1dEnsureMixedIndexByVertexLabel\x12*.grpc.EnsureMixedIndexByVer\
    texLabelRequest\x1a\x16.grpc.MixedVertexIndexB(\n\x13org.janusgraph.grpc\
    B\x0fManagementProtoP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
